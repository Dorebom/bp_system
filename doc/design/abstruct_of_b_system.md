Behavior systemに関する概要をメモする。

# システムコンセプト

システムの根幹(Hub,基底Nodeクラス)とUser設計部分を分離することを目的にシステムの改修を実施した。

利用者であるユーザにはできる限り最低限の設定ファイルで運用できるようにしたかったから

### Nodeに関して

設計者は、実行コード(Node type)と設定ファイル(json file)の2つを作成することになる。
Node typeは、Nodeの機能を記述するものであり、これだけでは個性がない。
例えると、家電の型式に当たる。実際には個体を特定するためのユニークなシリアル番号や設定ファイルが存在する。
これらの個性を記述するために、json fileが存在する。

json fileには以下を記述する必要がある。

- node_name : 個体を特定するためのユニークな名前である(生成時に重複する名前があると警告が表示される)
- node_type : 型式を特定するためのユニークな名前である(後述するストア登録時に重複する名前があると警告が表示される)
- task_main_periodic_time : Nodeの一定周期(msec)を設定する
- cmd_stack_size : 関連Nodeから設計した機能に関する命令を受けるためのスタックサイズを設定する
- sys_cmd_stack_size : Hubや上位Nodeからのシステム関連の命令を受けるためのスタックサイズを設定する
- print_log : コンソールへのlog表示有無を設定する
- use_udp_communication : NodeのUDP通信利用有無を設定する
- requirement_node_list : 関連して呼び出すNodeを設定する

この他にも、以下などの設定がある。

- transit_watch_dog_time : 関連Nodeの応答待ちなどtransit状態にステートマシンが遷移したときの待ち時間(msec)を設定する

また、ユーザが設計した機能に関する設定もこのjson fileに記述したほうがエコシステムに乗っかれる楽チンさがある。もちろん、別で作成したtomlやjson、DBへのアクセスなど好きな手段をとってもらって構わない。

Nodeは単体で機能することはほとんど稀で、複数のNode間で連携して動作することを想定することが一般的である。Nodeの内部状態を関連Nodeに開示するために"State"、Nodeへの命令を送信するために"Cmd"の共有メモリが存在する。behavior systemではjson fileの`requirement_node_list`に記述することで、ユーザは共有メモリの受け渡しを意識せずに実現できる。また、すべてのNodeを管理しているHubに問い合わせることで特定の"State"や"Cmd"、"Sys Cmd"の共有メモリを取得することができる。問い合わせに利用するのが、json fileに記述された`node_name`である。同じNode typeのNodeの中から特定のNodeを選択するために`node_name`が重要なことを注意されたい。したがって、UDP接続した外部システムからでも`node_name`さえ分かれば、Nodeを特定し、命令を送信することや状態をHub経由で取得できる。

[NOTE] HubやNodeは、関連するNodeの複数のStateやCmdをMapで保持している。これらをstd::stringで検索するのはメモリがもったいないし、遅いからintでシリアル番号管理している。このシリアル番号はHubが発行・管理しており、`node_name`が新規の場合に番号を発行し、問い合わせに対してシリアル番号を返す。

### ストアに関して

改修によってHubにはストア機能が追加された。使い方は以下の手順となる。

1. ユーザはmain関数の中で、`b_node`を継承して作成したNodeのインスタンスと一貫して使用する`node type`をストアに登録する。
2. ユーザはmain関数の中で、ストアに登録したNodeを`node type`、`json file`を指定して実行する。

細かな中身を説明すると、ストアに登録する際にNodeのインスタンスはスレッド停止状態で登録される。イメージとしては電源OFFの製品を商品棚に格納する感じである。実行時に、HubhaストアからNodeのインスタンスをクローンして取り出し、クローンに設定ファイルを登録して、シリアル番号管理を付加して、Nodeのスレッドを開始する。

